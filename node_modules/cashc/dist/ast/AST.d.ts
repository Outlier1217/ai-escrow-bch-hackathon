import { Type } from '@cashscript/utils';
import { TimeOp } from './Globals.js';
import AstVisitor from './AstVisitor.js';
import { BinaryOperator, NullaryOperator, UnaryOperator } from './Operator.js';
import { Location } from './Location.js';
import { SymbolTable, Symbol } from './SymbolTable.js';
export type Ast = SourceFileNode;
export declare abstract class Node {
    location: Location;
    abstract accept<T>(visitor: AstVisitor<T>): T;
}
export interface Named {
    name: string;
}
export interface Typed {
    type: Type;
}
export declare class SourceFileNode extends Node {
    contract: ContractNode;
    constructor(contract: ContractNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class ContractNode extends Node implements Named {
    name: string;
    parameters: ParameterNode[];
    functions: FunctionDefinitionNode[];
    symbolTable?: SymbolTable;
    constructor(name: string, parameters: ParameterNode[], functions: FunctionDefinitionNode[]);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class FunctionDefinitionNode extends Node implements Named {
    name: string;
    parameters: ParameterNode[];
    body: BlockNode;
    symbolTable?: SymbolTable;
    opRolls: Map<string, IdentifierNode>;
    constructor(name: string, parameters: ParameterNode[], body: BlockNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class ParameterNode extends Node implements Named, Typed {
    type: Type;
    name: string;
    constructor(type: Type, name: string);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare abstract class StatementNode extends Node {
}
export declare class VariableDefinitionNode extends StatementNode implements Named, Typed {
    type: Type;
    modifier: string[];
    name: string;
    expression: ExpressionNode;
    constructor(type: Type, modifier: string[], name: string, expression: ExpressionNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class TupleAssignmentNode extends StatementNode {
    left: {
        name: string;
        type: Type;
    };
    right: {
        name: string;
        type: Type;
    };
    tuple: ExpressionNode;
    constructor(left: {
        name: string;
        type: Type;
    }, right: {
        name: string;
        type: Type;
    }, tuple: ExpressionNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class AssignNode extends StatementNode {
    identifier: IdentifierNode;
    expression: ExpressionNode;
    constructor(identifier: IdentifierNode, expression: ExpressionNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class TimeOpNode extends StatementNode {
    timeOp: TimeOp;
    expression: ExpressionNode;
    message?: string | undefined;
    constructor(timeOp: TimeOp, expression: ExpressionNode, message?: string | undefined);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class RequireNode extends StatementNode {
    expression: ExpressionNode;
    message?: string | undefined;
    constructor(expression: ExpressionNode, message?: string | undefined);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class BranchNode extends StatementNode {
    condition: ExpressionNode;
    ifBlock: BlockNode;
    elseBlock?: BlockNode | undefined;
    constructor(condition: ExpressionNode, ifBlock: BlockNode, elseBlock?: BlockNode | undefined);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class BlockNode extends Node {
    statements?: StatementNode[] | undefined;
    symbolTable?: SymbolTable;
    constructor(statements?: StatementNode[] | undefined);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare abstract class ExpressionNode extends Node {
    type?: Type;
}
export declare class CastNode extends ExpressionNode implements Typed {
    type: Type;
    expression: ExpressionNode;
    size?: ExpressionNode | undefined;
    constructor(type: Type, expression: ExpressionNode, size?: ExpressionNode | undefined);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class FunctionCallNode extends ExpressionNode {
    identifier: IdentifierNode;
    parameters: ExpressionNode[];
    constructor(identifier: IdentifierNode, parameters: ExpressionNode[]);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class InstantiationNode extends ExpressionNode {
    identifier: IdentifierNode;
    parameters: ExpressionNode[];
    constructor(identifier: IdentifierNode, parameters: ExpressionNode[]);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class TupleIndexOpNode extends ExpressionNode {
    tuple: ExpressionNode;
    index: number;
    constructor(tuple: ExpressionNode, index: number);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class SliceNode extends ExpressionNode {
    element: ExpressionNode;
    start: ExpressionNode;
    end: ExpressionNode;
    constructor(element: ExpressionNode, start: ExpressionNode, end: ExpressionNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class BinaryOpNode extends ExpressionNode {
    left: ExpressionNode;
    operator: BinaryOperator;
    right: ExpressionNode;
    constructor(left: ExpressionNode, operator: BinaryOperator, right: ExpressionNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class UnaryOpNode extends ExpressionNode {
    operator: UnaryOperator;
    expression: ExpressionNode;
    constructor(operator: UnaryOperator, expression: ExpressionNode);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class NullaryOpNode extends ExpressionNode {
    operator: NullaryOperator;
    constructor(operator: NullaryOperator);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class ArrayNode extends ExpressionNode {
    elements: ExpressionNode[];
    constructor(elements: ExpressionNode[]);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class IdentifierNode extends ExpressionNode implements Named {
    name: string;
    definition?: Symbol;
    constructor(name: string);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare abstract class LiteralNode<T = any> extends ExpressionNode {
    value: T;
    toString(): string;
}
export declare class BoolLiteralNode extends LiteralNode<boolean> {
    value: boolean;
    constructor(value: boolean);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class IntLiteralNode extends LiteralNode<bigint> {
    value: bigint;
    constructor(value: bigint);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class StringLiteralNode extends LiteralNode<string> {
    value: string;
    quote: string;
    constructor(value: string, quote: string);
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class HexLiteralNode extends LiteralNode<Uint8Array> {
    value: Uint8Array;
    constructor(value: Uint8Array);
    toString(): string;
    accept<T>(visitor: AstVisitor<T>): T;
}
export declare class ConsoleStatementNode extends Node {
    parameters: ConsoleParameterNode[];
    constructor(parameters: ConsoleParameterNode[]);
    accept<T>(visitor: AstVisitor<T>): T;
}
export type ConsoleParameterNode = LiteralNode | IdentifierNode;
