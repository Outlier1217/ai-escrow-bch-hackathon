import { PrimitiveType, BytesType } from '@cashscript/utils';
import { binToHex } from '@bitauth/libauth';
export class Node {
}
export class SourceFileNode extends Node {
    constructor(contract) {
        super();
        this.contract = contract;
    }
    accept(visitor) {
        return visitor.visitSourceFile(this);
    }
}
export class ContractNode extends Node {
    constructor(name, parameters, functions) {
        super();
        this.name = name;
        this.parameters = parameters;
        this.functions = functions;
    }
    accept(visitor) {
        return visitor.visitContract(this);
    }
}
export class FunctionDefinitionNode extends Node {
    constructor(name, parameters, body) {
        super();
        this.name = name;
        this.parameters = parameters;
        this.body = body;
        this.opRolls = new Map();
    }
    accept(visitor) {
        return visitor.visitFunctionDefinition(this);
    }
}
export class ParameterNode extends Node {
    constructor(type, name) {
        super();
        this.type = type;
        this.name = name;
    }
    accept(visitor) {
        return visitor.visitParameter(this);
    }
}
export class StatementNode extends Node {
}
export class VariableDefinitionNode extends StatementNode {
    constructor(type, modifier, name, expression) {
        super();
        this.type = type;
        this.modifier = modifier;
        this.name = name;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitVariableDefinition(this);
    }
}
export class TupleAssignmentNode extends StatementNode {
    constructor(
    // TODO: Use an IdentifierNode instead of a custom type
    left, right, tuple) {
        super();
        this.left = left;
        this.right = right;
        this.tuple = tuple;
    }
    accept(visitor) {
        return visitor.visitTupleAssignment(this);
    }
}
export class AssignNode extends StatementNode {
    constructor(identifier, expression) {
        super();
        this.identifier = identifier;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitAssign(this);
    }
}
export class TimeOpNode extends StatementNode {
    constructor(timeOp, expression, message) {
        super();
        this.timeOp = timeOp;
        this.expression = expression;
        this.message = message;
    }
    accept(visitor) {
        return visitor.visitTimeOp(this);
    }
}
export class RequireNode extends StatementNode {
    constructor(expression, message) {
        super();
        this.expression = expression;
        this.message = message;
    }
    accept(visitor) {
        return visitor.visitRequire(this);
    }
}
export class BranchNode extends StatementNode {
    constructor(condition, ifBlock, elseBlock) {
        super();
        this.condition = condition;
        this.ifBlock = ifBlock;
        this.elseBlock = elseBlock;
    }
    accept(visitor) {
        return visitor.visitBranch(this);
    }
}
export class BlockNode extends Node {
    constructor(statements) {
        super();
        this.statements = statements;
    }
    accept(visitor) {
        return visitor.visitBlock(this);
    }
}
export class ExpressionNode extends Node {
}
export class CastNode extends ExpressionNode {
    constructor(type, expression, size) {
        super();
        this.type = type;
        this.expression = expression;
        this.size = size;
    }
    accept(visitor) {
        return visitor.visitCast(this);
    }
}
export class FunctionCallNode extends ExpressionNode {
    constructor(identifier, parameters) {
        super();
        this.identifier = identifier;
        this.parameters = parameters;
    }
    accept(visitor) {
        return visitor.visitFunctionCall(this);
    }
}
export class InstantiationNode extends ExpressionNode {
    constructor(identifier, parameters) {
        super();
        this.identifier = identifier;
        this.parameters = parameters;
    }
    accept(visitor) {
        return visitor.visitInstantiation(this);
    }
}
export class TupleIndexOpNode extends ExpressionNode {
    constructor(tuple, index) {
        super();
        this.tuple = tuple;
        this.index = index;
    }
    accept(visitor) {
        return visitor.visitTupleIndexOp(this);
    }
}
export class SliceNode extends ExpressionNode {
    constructor(element, start, end) {
        super();
        this.element = element;
        this.start = start;
        this.end = end;
    }
    accept(visitor) {
        return visitor.visitSlice(this);
    }
}
export class BinaryOpNode extends ExpressionNode {
    constructor(left, operator, right) {
        super();
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
    accept(visitor) {
        return visitor.visitBinaryOp(this);
    }
}
export class UnaryOpNode extends ExpressionNode {
    constructor(operator, expression) {
        super();
        this.operator = operator;
        this.expression = expression;
    }
    accept(visitor) {
        return visitor.visitUnaryOp(this);
    }
}
export class NullaryOpNode extends ExpressionNode {
    constructor(operator) {
        super();
        this.operator = operator;
    }
    accept(visitor) {
        return visitor.visitNullaryOp(this);
    }
}
export class ArrayNode extends ExpressionNode {
    constructor(elements) {
        super();
        this.elements = elements;
    }
    accept(visitor) {
        return visitor.visitArray(this);
    }
}
export class IdentifierNode extends ExpressionNode {
    constructor(name) {
        super();
        this.name = name;
    }
    accept(visitor) {
        return visitor.visitIdentifier(this);
    }
}
export class LiteralNode extends ExpressionNode {
    toString() {
        return `${this.value}`;
    }
}
export class BoolLiteralNode extends LiteralNode {
    constructor(value) {
        super();
        this.value = value;
        this.type = PrimitiveType.BOOL;
    }
    accept(visitor) {
        return visitor.visitBoolLiteral(this);
    }
}
export class IntLiteralNode extends LiteralNode {
    constructor(value) {
        super();
        this.value = value;
        this.type = PrimitiveType.INT;
    }
    accept(visitor) {
        return visitor.visitIntLiteral(this);
    }
}
export class StringLiteralNode extends LiteralNode {
    constructor(value, quote) {
        super();
        this.value = value;
        this.quote = quote;
        this.type = PrimitiveType.STRING;
    }
    accept(visitor) {
        return visitor.visitStringLiteral(this);
    }
}
export class HexLiteralNode extends LiteralNode {
    constructor(value) {
        super();
        this.value = value;
        this.type = new BytesType(value.byteLength);
    }
    toString() {
        return `0x${binToHex(this.value)}`;
    }
    accept(visitor) {
        return visitor.visitHexLiteral(this);
    }
}
export class ConsoleStatementNode extends Node {
    constructor(parameters) {
        super();
        this.parameters = parameters;
    }
    accept(visitor) {
        return visitor.visitConsoleStatement(this);
    }
}
//# sourceMappingURL=AST.js.map